## IDEA

### 1. 메모리 관리 시뮬레이터

- **사용 개념**: 포인터, 동적 메모리 할당 (`malloc`, `free`), 배열과 포인터, 구조체.
- **설명**: 메모리 블록을 관리하는 프로그램을 작성하여 메모리 할당과 해제 과정을 시뮬레이션합니다. 사용자는 다양한 크기의 메모리 블록을 할당하고 해제할 수 있으며, 메모리 파편화 문제도 시각적으로 출력하여 관리합니다.
- **세부 기능**:
  - 사용자는 블록 크기를 지정하여 메모리를 할당하거나 해제.
  - 메모리 블록의 현재 상태를 실시간으로 출력 (비어 있는 공간, 할당된 공간).
  - **메모리 파편화** 문제를 해결하는 방법 구현 (예: **최초 적합**(First Fit), **최적 적합**(Best Fit) 알고리즘).
- **학습 포인트**:
  - **포인터와 동적 메모리 할당**의 이해가 깊어지며, 메모리 파편화 문제를 다루면서 효율적인 메모리 관리의 중요성을 학습.
  - **구조체와 배열**을 사용하여 메모리 블록 상태를 저장하고 처리하는 방법을 익힘.

### 2. 간단한 HTTP 서버

- **사용 개념**: 함수, 구조체, 포인터, 파일 입출력, 소켓 프로그래밍.
- **설명**: 간단한 HTTP 서버를 구현하여 클라이언트의 요청을 처리하고, HTML 파일을 반환하는 프로그램을 작성합니다. GET 요청을 처리하는 간단한 웹 서버를 구축하며, 사용자 요청에 따라 파일을 반환하거나 응답 메시지를 전달합니다.
- **세부 기능**:
  - 클라이언트의 요청을 수신하고, HTTP 요청을 파싱.
  - 파일을 열어 HTML 콘텐츠를 읽어와 클라이언트에게 반환.
  - 간단한 상태 코드를 반환 (예: 200 OK, 404 Not Found).
- **학습 포인트**:
  - **소켓 프로그래밍**을 통해 네트워크 통신의 기초를 익히고, 클라이언트-서버 모델을 학습.
  - **구조체**와 **포인터**를 사용하여 요청 데이터를 파싱하고, 응답 데이터를 관리하는 방법을 학습.

### 3. 텍스트 기반 미로 게임

- **사용 개념**: 배열, 구조체, 함수, 포인터.
- **설명**: 2차원 배열로 구성된 미로에서 플레이어가 미로의 출구를 찾는 텍스트 기반 게임을 만듭니다. 플레이어는 상하좌우로 움직이며, 목표는 미로를 탈출하는 것입니다. 미로는 프로그램 시작 시 랜덤하게 생성되거나 미리 정의된 파일에서 읽어올 수 있습니다.
- **세부 기능**:
  - 2차원 배열로 미로를 정의하고, 각 셀의 상태 (벽, 빈 공간, 플레이어 위치)를 표현.
  - 사용자가 방향키를 입력하여 캐릭터를 상하좌우로 이동.
  - 미로 탈출에 성공하면 게임 종료 메시지를 출력.
- **학습 포인트**:
  - **2차원 배열**을 사용해 데이터 구조를 관리하고, 플레이어의 위치를 업데이트하는 방법을 익힘.
  - **구조체와 포인터**로 게임 상태를 관리하여 여러 변수들을 하나의 구조체에 담아 효율적으로 처리.

### 4. 간단한 데이터베이스 시스템

- **사용 개념**: 파일 입출력, 구조체, 포인터.
- **설명**: 데이터를 파일에 저장하고 검색할 수 있는 간단한 데이터베이스 시스템을 구축합니다. 데이터를 구조체로 관리하며, 파일에서 데이터를 읽고 쓰는 기능을 제공합니다. 예를 들어, 사용자가 이름과 나이를 입력하면 파일에 저장하고, 이후에 해당 데이터를 검색할 수 있습니다.
- **세부 기능**:
  - 데이터 입력: 사용자로부터 데이터를 입력받아 파일에 저장.
  - 데이터 검색: 특정 키워드로 파일에서 데이터를 검색하고 출력.
  - 데이터 삭제/수정 기능도 추가 가능.
- **학습 포인트**:
  - **파일 입출력**을 통해 데이터를 영구적으로 저장하는 방법을 익힘.
  - **구조체**로 데이터를 구조화하여 관리하고, **포인터**를 사용하여 파일에서 읽은 데이터를 적절하게 처리하는 능력을 기름.

### 5. 간단한 스프레드시트 프로그램

- **사용 개념**: 2차원 배열, 구조체, 파일 입출력, 포인터.
- **설명**: 각 셀이 숫자를 저장하는 간단한 스프레드시트 프로그램을 만들고, 사용자가 값을 입력하면 다른 셀에서 이를 참조하여 계산할 수 있도록 구현합니다. 예를 들어, B2 셀이 A1+B1 값을 가지도록 설정할 수 있습니다.
- **세부 기능**:
  - 셀 값 입력: 사용자가 특정 셀에 값을 입력.
  - 셀 참조: 다른 셀의 값을 참조하여 계산할 수 있도록 구현 (예: `=A1 + B1`).
  - 파일 저장/불러오기 기능.
- **학습 포인트**:
  - **2차원 배열**을 사용하여 스프레드시트 데이터를 관리.
  - **구조체와 포인터**를 활용해 각 셀의 데이터를 참조하고 계산하는 방법을 익힘.

### 6. 간단한 소켓 기반 채팅 프로그램

- **사용 개념**: 소켓 프로그래밍, 구조체, 포인터.
- **설명**: 여러 클라이언트가 동시에 접속하여 서로 메시지를 주고받을 수 있는 간단한 채팅 프로그램을 작성합니다. 서버는 각 클라이언트의 연결을 관리하고, 클라이언트가 보낸 메시지를 다른 클라이언트에게 중계합니다.
- **세부 기능**:
  - 서버는 여러 클라이언트와의 연결을 관리하고, 클라이언트 간 메시지를 중계.
  - 클라이언트는 서버에 연결한 후 메시지를 입력하면 다른 클라이언트에게 전송.
  - 여러 클라이언트가 동시에 접속할 수 있도록 **비동기 처리** 구현.
- **학습 포인트**:
  - **소켓 프로그래밍**을 통해 TCP 연결을 다루고, 비동기적인 네트워크 통신에 대해 학습.
  - **구조체**로 클라이언트의 상태를 저장하고, **포인터**로 메시지 버퍼를 관리하여 실시간으로 데이터를 주고받는 방법을 익힘.

### 7. 운영 체제 시뮬레이터 (스케줄링 알고리즘)

- **사용 개념**: 구조체, 포인터, 큐(Queue) 구현, 함수.
- **설명**: 여러 프로세스의 CPU 실행 순서를 관리하는 운영 체제의 스케줄링 알고리즘을 구현합니다. 라운드 로빈, 우선순위 기반 스케줄링 등의 알고리즘을 통해 각 프로세스의 실행 시간을 할당하고, 대기 큐에 프로세스를 관리합니다.
- **세부 기능**:
  - **라운드 로빈**: 모든 프로세스가 동일한 시간만큼 CPU를 할당받아 실행됨.
  - **우선순위 스케줄링**: 우선순위가 높은 프로세스가 먼저 실행되고, 우선순위가 낮은 프로세스는 대기.
  - **프로세스 상태 관리**: 각 프로세스는 실행 중, 대기 중, 종료 등의 상태를 가짐.
- **학습 포인트**:
  - **큐(Queue)** 자료구조를 직접 구현하여 프로세스 대기열을 관리하고, 각 프로세스가 CPU 자원을 효율적으로 사용하도록 스케줄링.
  - **구조체**와 **포인터**를 사용해 각 프로세스의 상태를 저장하고 관리하는 방법을 익힘.
